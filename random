local SemiObfuscator = {}

local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"

-- Reemplazar Random.new() por math.random para exploits
local random = {
    NextInteger = function(self, min, max)
        return math.random(min, max)
    end
}

-- Inicializar math.random
math.randomseed(tick())

-- Tablas de mapeo
local functionMap = {}
local variableMap = {}

-- Configuración
local config = {
    minNameLength = 4,
    maxNameLength = 12,
    enableStringEncoding = true,
    enableFunctionRenaming = true,
    enableVariableRenaming = true,
    enableCodeFlattening = false,
    enableJunkCode = true
}

-- Generar nombres aleatorios
local function generateRandomName()
    local length = random:NextInteger(config.minNameLength, config.maxNameLength)
    local name = ""
    for i = 1, length do
        local randIndex = random:NextInteger(1, #chars)
        name = name .. string.sub(chars, randIndex, randIndex)
    end
    return name
end

-- Codificación avanzada (versión simplificada para exploits)
local function advancedEncode(str)
    local encoded = ""
    local key = random:NextInteger(10000, 99999)
    
    -- Método simple XOR que funciona en exploits
    for i = 1, #str do
        local charCode = string.byte(str, i)
        local encodedChar = bit32 and bit32.bxor(charCode, (key + i) % 256) or (charCode ~ (key + i)) % 256
        encoded = encoded .. string.format("%02X", encodedChar)
    end
    return {data = encoded, key = key, method = 1}
end

-- Obtener nombre único para funciones/variables
local function getUniqueName(originalName, type)
    local map = (type == "function") and functionMap or variableMap
    if map[originalName] then
        return map[originalName]
    end
    
    local newName
    repeat
        newName = generateRandomName()
    until not map[newName]
    
    map[originalName] = newName
    return newName
end

-- Generar código basura
local function generateJunkCode()
    local junkTypes = {
        function()
            local vars = {}
            for i = 1, random:NextInteger(2, 5) do
                table.insert(vars, generateRandomName())
            end
            return "local " .. table.concat(vars, ",") .. "=" .. random:NextInteger(1, 1000)
        end,
        function()
            return "if false then " .. generateRandomName() .. "=" .. random:NextInteger(1, 100) .. " end"
        end,
        function()
            return "for " .. generateRandomName() .. "=1," .. random:NextInteger(10, 50) .. " do end"
        end
    }
    return junkTypes[random:NextInteger(1, #junkTypes)]()
end

-- Renombrar funciones y variables (versión simplificada)
local function renameIdentifiers(codeStr)
    local processedCode = codeStr
    
    -- Solo renombrar funciones por ahora
    local patterns = {
        "function%s+([%a_][%w_]*)%s*%(",
        "local%s+([%a_][%w_]*)%s*=%s*function%s*%(",
        "([%a_][%w_]*)%s*=%s*function%s*%("
    }
    
    for _, pattern in ipairs(patterns) do
        local startPos = 1
        while true do
            local funcName = string.match(processedCode, pattern, startPos)
            if not funcName then break end
            
            if not string.find(funcName, "^[A-Z][A-Z_0-9]*$") and #funcName > 1 then
                local newName = getUniqueName(funcName, "function")
                processedCode = string.gsub(processedCode, "%f[%a_]"..funcName.."%f[%A_]", newName, 1)
            end
            
            startPos = string.find(processedCode, pattern, startPos) or #processedCode
            startPos = startPos + 1
            if startPos > #processedCode then break end
        end
    end
    
    return processedCode
end

-- Codificar strings (versión simplificada)
local function encodeStringsAdvanced(codeStr)
    if not config.enableStringEncoding then
        return codeStr, {}
    end
    
    local processedCode = codeStr
    local encodedStrings = {}
    local stringIndex = 1
    
    local function processQuotes(quoteChar)
        local startPos = 1
        while startPos <= #processedCode do
            local quoteStart = string.find(processedCode, quoteChar, startPos, true)
            if not quoteStart then break end
            
            -- Buscar cierre de comilla
            local contentStart = quoteStart + 1
            local quoteEnd = string.find(processedCode, quoteChar, contentStart, true)
            
            if quoteEnd then
                local content = string.sub(processedCode, contentStart, quoteEnd - 1)
                
                if #content > 2 then
                    local encodedData = advancedEncode(content)
                    encodedStrings[stringIndex] = encodedData
                    
                    local replacement = "_S[" .. stringIndex .. "]"
                    local before = string.sub(processedCode, 1, quoteStart - 1)
                    local after = string.sub(processedCode, quoteEnd + 1)
                    
                    processedCode = before .. replacement .. after
                    stringIndex = stringIndex + 1
                    startPos = #before + #replacement + 1
                else
                    startPos = quoteEnd + 1
                end
            else
                break
            end
        end
    end
    
    processQuotes('"')
    processQuotes("'")
    
    return processedCode, encodedStrings
end

-- Generar decodificador
local function generateObfuscatedDecoder(encodedStrings)
    local decoderCode = {
        "local _S={}",
        "local function decoder(d,k)",
        "local r=\"\"",
        "for i=1,#d,2 do",
        "local h=string.sub(d,i,i+1)",
        "local e=tonumber(h,16)",
        "local c=bit32 and bit32.bxor(e,(k+i)%256) or (e ~ (k+i))%256",
        "r=r..string.char(c)",
        "end",
        "return r",
        "end"
    }
    
    for i, encodedData in pairs(encodedStrings) do
        table.insert(decoderCode, "_S[" .. i .. "]=decoder(\"" .. encodedData.data .. "\"," .. encodedData.key .. ")")
    end
    
    return table.concat(decoderCode, "\n")
end

-- Función principal de ofuscación
function SemiObfuscator.Obfuscate(code, userConfig)
    -- Resetear mapeos
    functionMap = {}
    variableMap = {}
    
    local obfuscatedCode = code
    
    -- Paso 1: Renombrar identificadores
    if config.enableFunctionRenaming then
        obfuscatedCode = renameIdentifiers(obfuscatedCode)
    end
    
    -- Paso 2: Codificar strings
    local encodedStrings
    if config.enableStringEncoding then
        obfuscatedCode, encodedStrings = encodeStringsAdvanced(obfuscatedCode)
    end
    
    -- Paso 3: Generar decodificador
    local decoderCode = ""
    if encodedStrings and next(encodedStrings) then
        decoderCode = generateObfuscatedDecoder(encodedStrings)
    end
    
    -- Paso 4: Agregar código basura
    if config.enableJunkCode then
        local junkLines = {}
        for i = 1, random:NextInteger(2, 5) do
            table.insert(junkLines, generateJunkCode())
        end
        obfuscatedCode = table.concat(junkLines, "\n") .. "\n" .. obfuscatedCode
    end
    
    -- Combinar todo
    local finalCode = decoderCode
    if decoderCode ~= "" then
        finalCode = finalCode .. "\n\n" .. obfuscatedCode
    else
        finalCode = obfuscatedCode
    end
    
    return finalCode
end

-- Configurar el ofuscador
function SemiObfuscator.Configure(newConfig)
    for k, v in pairs(newConfig) do
        config[k] = v
    end
end

return SemiObfuscator
