local chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"
local random = Random.new()

-- Tabla de mapeo para nombres de funciones
local functionMap = {}

-- Función para generar nombres aleatorios
local function generateRandomName(length)
    local name = ""
    for i = 1, length do
        local randIndex = random:NextInteger(1, #chars)
        name = name .. string.sub(chars, randIndex, randIndex)
    end
    return name
end

-- Sistema de codificación personalizado (no Base64)
local function customEncode(str)
    local encoded = ""
    local key = 142857 -- Número cíclico no común
    for i = 1, #str do
        local charCode = string.byte(str, i)
        local encodedChar = bit32.bxor(charCode, (key + i) % 256)
        encoded = encoded .. string.format("%02X", encodedChar)
    end
    return encoded
end

local function customDecode(encoded)
    local decoded = ""
    local key = 142857
    for i = 1, #encoded, 2 do
        local hex = string.sub(encoded, i, i + 1)
        local encodedChar = tonumber(hex, 16)
        local charCode = bit32.bxor(encodedChar, (key + (i + 1) / 2) % 256)
        decoded = decoded .. string.char(charCode)
    end
    return decoded
end

-- Función para obtener nombres únicos
local function getUniqueName(originalName, isFunction)
    if functionMap[originalName] then
        return functionMap[originalName]
    end
    
    local newName
    repeat
        newName = generateRandomName(8)
    until not functionMap[newName]
    
    functionMap[originalName] = newName
    return newName
end

-- Función principal de ofuscación
function SemiObfuscator.Obfuscate(code)
    -- Resetear el mapeo
    functionMap = {}
    
    -- Buscar y reemplazar nombres de funciones
    local function replaceFunctionNames(codeStr)
        -- Patrón para encontrar declaraciones de funciones
        local patterns = {
            "function%s+([%a_][%w_]*)%s*%(",
            "local%s+([%a_][%w_]*)%s*=%s*function%s*%(",
            "([%a_][%w_]*)%s*=%s*function%s*%%("
        }
        
        local processedCode = codeStr
        
        for _, pattern in ipairs(patterns) do
            for funcName in string.gmatch(processedCode, pattern) do
                if not string.find(funcName, "^[A-Z][A-Z_0-9]*$") then -- No ofuscar constantes en mayúsculas
                    local newName = getUniqueName(funcName, true)
                    processedCode = string.gsub(processedCode, "\\b"..funcName.."\\b", newName)
                end
            end
        end
        
        return processedCode
    end
    
    -- Codificar strings
    local function encodeStrings(codeStr)
        local encodedCode = codeStr
        
        -- Encontrar y codificar strings entre comillas
        for quotedStr in string.gmatch(codeStr, "(['\"])(.-)\\1") do
            local quote, content = string.match(quotedStr, "(['\"])(.-)\\1")
            if #content > 2 then -- Solo codificar strings de más de 2 caracteres
                local encoded = customEncode(content)
                encodedCode = string.gsub(encodedCode, quote..content..quote, 'decoder("'..encoded..'")')
            end
        end
        
        return encodedCode
    end
    
    -- Procesar el código
    local obfuscatedCode = code
    obfuscatedCode = replaceFunctionNames(obfuscatedCode)
    obfuscatedCode = encodeStrings(obfuscatedCode)
    
    -- Generar el decodificador
    local decoderFunction = [[
    local function afz(encoded)
    local ddd = 142857
    local rmx = ""
    for i = 1, #encoded, 2 do
        local hex = string.sub(encoded, i, i + 1)
        local encodedChar = tonumber(hex, 16)
        local charCode = bit32.bxor(encodedChar, (key + (i + 1) / 2) % 256)
        decoded = decoded .. string.char(charCode)
    end
    return decoded
    end
]]
    
    -- Combinar todo
    local finalCode = decoderFunction .. "\\n\\n" .. obfuscatedCode
    
    return finalCode
end

return SemiObfuscator
